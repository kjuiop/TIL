## MySQL 서버 = MySQL 엔진 + 스토리지 엔진

---

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 나눠볼 수 있다.

MySQL 엔진은 클라이언트부터 오는 요청 처리 (요청된 SQL 문장을 분석, 최적화, …)를 담당하고, 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 조회하는 부분을 담당한다.

### MySQL 엔진

- Connection Handler : 커넥션 및 쿼리 요청을 처리 담당
- SQL 인터페이스 : DML ,DDL, Procedure, View 등 SQL 인터페이스 제공 담당
- SQL 파서 (parser) : SQL 문법 오류 탐지 및 SQL 쿼리 문장을 MySQL 이 처리하기 좋은 토큰 단위로 나눠서 트리 형태로 파싱 하는 작업 담당
- SQL 옵티마이저(optimizer) : 쿼리의 최적화된 실행 담당
- 캐시와 버퍼 : 성능 향상을 위한 보조 저장소 기능 담당

### 스토리지 엔진

- 스토리지 엔진은 MySQL 엔진과 플러그인 형태로 연동/분리 가능하고 핸들러 API (핸들러 요청) 를 통해 스토리지 엔진에 읽기/쓰기 요청이 가능

# MySQL 스레드 구조

---

MySQL 스레드 = foreground thread + background thread

- 포그라운드 스레드
    - 클라이언트/사용자가 요청한 쿼리 문장을 처리하는 스레드 (고객 창구 역할)
    - 데이터 조회 스레드 (데이터 버퍼나 캐시 또는 직접 디스크나 인덱스 파일로 접근하여 데이터를 가져오는 스레드)

- 백그라운드 스레드
    - insert buffer 를 병합하는 스레드
    - 로그 기록 스레드
    - innoDB 버퍼 풀의 데이터를 디스크로 기록(Write) 하는 스레드
    - 데이터를 버퍼로 읽어들이는 스레드
    - 잠금, 데드락을 모니터링하는 스레드
    - 모든 백그라운드 스레드를 관리하는 메인 스레드

포그라운드 스레드는 ‘thread_cache_size’ 설정 값에 따라 일정 스레드 개수로 유지된다.

## 메모리 구조와 할당

---

MySQL 의 메모리 구조는 크게 글로벌 메모리 영역과 로컬(세션) 메모리 영역으로 나눠볼 수 있다.

글로벌 영역은 많은 스레드에 의해 공유되는 영역이고 로컬 영역은 많은 스레드에 의해 공유되지 않는 독립적인 영역이다.

- 글로벌 메모리
    - MySQL 서버를 실행할 때 운영체제로부터 설정한 만큼 할당받는 영역
    - 모든 스레드로부터 공유되는 영역
- 로컬(세션) 메모리
    - 클라이언트 스레드가 쿼리를 처리하는데 쓰이는 영역
    - 스레드 별로 독립적이라 절대 공유되지 않는 영역
    - 쿼리의 용도 별로 할당이 될 때도 있고 아예 할당되지 않을 때도 있음

## 쿼리 실행 구조

- 파서(parser) 가 들어온 쿼리 문장에 대해서 문법(Syntax) 확인을 하고 쿼리 문장을 적절한 단위로 분할하여 파서 트리(parser tree) 를 만든다.
- 전처리기(pre-processor) 가 앞에서 만들어진 파서 트리를 보고 구조적으로 문제가 있는지 확인한다.
    - 예를 들어, 없는 테이블, 컬럼 등에 접근한다거나 테이블에 접근하려고 보니 권한이 없다거나 하는 등
- 옵티마이저(optimizer) 가 요청받은 쿼리를 어떻게하면 가장 적은 비용으로 빠르게 즉, 최적으로 처리할지를 결정한다.
    - 앞으로 개발자가 해야할 일은 이 옵티마이저가 더 나은 결정(실행 계획 생성)을 할 수 있도록 쿼리를 작성하는 것이다.
- 실행 엔진은 옵티마이저에 의해 결정된 실행 계획대로 핸들러에게 지시한다.
    - 임시테이블을 만들어라
    - where 조건대로 레코드 읽어와라
    - 읽은 레코드를 임시 테이블에 써라
- 핸들러 (스토리지 엔진) 은 실행 엔진이 내려준 지시대로 작업을 수행한다.

## 복제 (Replication)

- 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 하는 실시간 동기화하는 기술이다.
- 보통 읽기, 쓰기 모두 가능한 마스터 역할의 마스터 서버(Primary) 와 읽기만 가능한 슬레이브 역할의 슬레이브 서버(Secondary) 로 나뉜다.
- 마스터 서버에서만 쓰기가 가능하기에 마스터에 쓰인 데이터를 슬레이브에 복제하여 데이터를 동기화한다.
- 마스터 역할의 서버는 복제를 위해서 MySQL 바이너리 로그를 활성화해서 남겨야 한다.
- 바이너리 로그에는 DML(데이터를 조작하는 문장)과 DDL(스키마를 변경하는 문장)이 기록된다.
- 슬레이브 역할의 서버에서 마스터 역할의 서버로 동기화 요청이 온다면 “Binlog dump” 라는 스레드가 동기화를 수행한다.
- 슬레이브 역할의 서버에서는 마스터 역할의 서버에 접속할 정보 (IP, PORT, 계정) 을 가지고 있으면 된다.
- 그리고 슬레이브 역할의 서버는 마스터 역할의 서버로 데이터 동기화 요청을 하고 받아온 내역을 릴레이 로그에 기록한다. (참고로 바이너리 로그와 릴레이 로그는 내용이 동일하다.)

### 복제 시 주의사항

- 하나의 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
    - 읽기 전용으로 설정하지 않으면 개발자나 사용자 실수로 슬레이브에 쓰기 요청을 해서 데이터가 기록될 위험이 있음
- 슬레이브 서버 장비와 마스터 서버의 장비 사양은 동일한 것으로 사용
- 복제가 불필요한 경우 바이너리 로그 중지 (바이너리 로그를 작성하는 일은 비용이 굉장히 큰 작업)
- 바이너리 로그와 트랜잭션 격리 수준
    - 바이너리 로그 기록 방식 2가지
        - STATEMENT 방식 : 마스터에서 실행된 쿼리 자체를 기록
            - 쿼리 자체를 기록하기 때문에 복제할 때 네트워크로 전달되는 용량이 적어서 복제 성능 좋긴 하나, 트랜잭션 격리 수준을 REPEATABLE READ 수준 이상으로 해야 해서 레코드 간의 잠금 등 락에 영향을 끼친다.
        - ROW 방식 : 마스터에서 실행된 쿼리로 인해 변경된 레코드를 기록
            - 변경 사항이 많은 경우, 네트워크로 전달되어야 할 레코드 양이 많아져서 복제 성능이 안 좋긴 하나, 트랜잭션 격리 수준을 READ COMMITED 수준에서도 동작 가능하여 락에서 race-condition 은 줄어든다.

# Reference

---

- [https://jeong-pro.tistory.com/239](https://jeong-pro.tistory.com/239)


