<aside>
💡 주키퍼의 Watcher 이벤트를 받는 내부 소스는 Mutax 의 영역에 들어올까?
하나의 메인쓰레드에 의해 여러개의 Watcher 를 등록한다고 하였을 때,
Mutax 의 영역에 들어올 거 같은데…

</aside>

<aside>
💡 여러 개의 노드에 UsingWatcher 를 걸어놓고 싶은데, 각 UsingWatcher 를 고루틴으로 빼는게 맞을까?

</aside>

### Zookeeper 의 UsingWatcher 메서드 동작 방식

---

- Curator 에서 UsingWatcher 메서드는 지정된 Watcher 인스턴스를 사용하여 이벤트를 감시하도록 설정합니다.
- Zookeeper client 가 이벤트를 수신하면 해당 이벤트를 처리하는 Watcher 의 process 메서드가 호출됩니다.
- 이때 process 메서드는 zookeeper 의 이벤트 스레드에 의해서 실행됩니다.
    - process 메서드 내에서 시간이 오래 걸리는 작업을 수행하면 Zookeeper 이벤트 스레드가 블로킹되어 다른 이벤트처리가 지연될 수 있다는 점
    - process 메서드 내에서 시간이 오래 걸리는 작업을 별도의 스레드로 처리하는 것이 적합하다.

### Zookeeper 의 이벤트스레드를 사용하여 이벤트 처리

---

- Zookeeper 는 분산 시스템에서 데이터를 저장하고 동기화하는데 사용되는 높은 신뢰성을 가진 프로젝트이다.
- Zookeeper 클라이언트는 이벤트 스레드를 사용하여 Zookeeper 서버에서 전달되는 이벤트를 처리합니다.
- 이벤트 스레드의 특징
    - 단일 스레드 : 이벤트 스레드는 클라이언트당 하나만 존재하며, 모든 이벤트 처리를 순차적으로 수행합니다. 이는 동시성 문제를 피할 수 있지만, 이벤트 처리에 시간이 오래 걸리는 경우 다른 이벤트 처리가 지연될 수 있습니다.
    - 비동기 처리 : 이벤트 스레드는 zookeeper 서버에서 전달되는 이벤트를 처리하기 위해 비동기적으로 동작합니다. 이를 통해 클라이언트의 메인 스레드가 다른 작업을 계속 수행할 수 있습니다.
    - 이벤트 처리 : 이벤트 스레드는 다양한 종류의 이벤트를 처리할 수 있습니다.
        - 노드 생성, 노드 삭제, 노드 업데이트, 연결 상태 변경 등의 이벤트를 처리할 수 있습니다.
        - 이벤트 처리 시 등록된 Watcher 의 process 메서드가 호출됩니다.
    - Watcher 사용 : Zookeeper 클라이언트는 Watcher 인터페이스를 구현하여 이벤트처리를 커스터마이즈할 수 있습니다. 이벤트 스레드는 등록된 Watcher 의 process 메서드를 호출하여 이벤트를 처리합니다.

<aside>
💡 Zookeeper 클라이언트를 사용하여 여러개의 Watcher 를 사용하는 경우 각 Watcher 는 독립적으로 동작한다.

</aside>

- Zookeeper 클라이언트는 Watcher 를 사용하여 Zookeeper 서버에서 전달되는 이벤트를 처리합니다.
- Watcher 는 이벤트가 발생할 때마다 Zookeeper 클라이언트에게 알리는 역할을 수행합니다.
- 여러 개의 Watcher 이벤트가 발생하더라도 이벤트 스레드에서 순차적으로 처리되며, 동시에 실행되지 않습니다. 따라서 하나의 스레드에서 이벤트를 처리하면 이벤트 처리 간 순서가 보장되지만, 이벤트 처리 시간이 오래 걸리는 경우 성능이 저하될 수 있습니다.

- application 에서 이벤트 처리함수를 고루틴으로 사용한다고 하였을 때, 주키퍼 내의 이벤트 스레드는 단일 쓰레드이며, 순차적으로 호출하기 때문에 고루틴이 동시에 호출될 일은 없다.
- 하지만 고루틴의 내부 함수가 시간이 오래 걸리는 경우 동시에 동작하는 경우는 발생할 수 있기 때문에 동기화 처리를 해줘야 한다.

### Golang 의 Mutax

---

- Golang 에서 mutex 는 mutual exlusion 의 줄임말로, 여러 고루틴이 동시에 공유 데이터에 액세스하는 것을 방지하기 위한 동기화 원리이다.
- 공유 데이터를 보호하기 위해 뮤택스를 사용하여 특정 코드 영역이 한 번에 하나의 고루틴에 의해서만 실행되도록 한다.
- 이렇게 함으로써 동시성 문제를 방지할 수 있다.
    - 경쟁 조건
    - 데이터 경쟁
- Go 에서 sync 패키지의 mutex 구조체 사용 방법
    - sync.Mutex 타입의 변수를 선언
        - `var myMutex sync.Mutex`
    - 공유 데이터에 액세스하기 전에 Lock() 메서드를 호출하여 뮤텍스를 잠급니다.
        - `myMutex.Lock()`
    - 공유 데이터를 안전하게 수정하거나 사용합니다.
    - 공유 데이터 작업이 완료되면 Unlock() 메서드를 호출하여 뮤텍스를 해제합니다.
        - `myMutex.Unlock()`
    - 뮤텍스를 사용하면 공유 데이터를 수정하거나 사용하는 코드 영역이 한 번에 하나의 고루틴에 의해서만 실행되므로, 동시성 문제를 효과적으로 방지할 수 있습니다.****