# 프로그램 (Program) 과 프로세스 (Process)

---


- 프로그램은 HDD, SSD (저장장치) 에 저장된 명령문의 집합체를 말합니다.
    - 프로그램은 컴퓨터 관점에서 하드디스크, 저장장치만 사용하는 수동적인 존재
- 프로세스는 실행중인 프로그램이다.
    - 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 실행중인 프로그램, 프로세스라고 한다.
    - 프로세스는 메모리도 사용하고, 운영체제의 CPU 스케줄링 알고리즘에 따라 CPU 도 사용하고, 입출력 작업을 수행하기 때문에 능동적인 존재입니다.
    - 프로세스의 구조
        - CODE, DATA, HEAP, STACK 영역으로 구분되어있다.
            - CODE 는 자신을 실행하는 코드가 저장되어 있다.
            - DATA 영역은 전역변수와 Static(정적) 변수가 저장되어 있습니다.
            - STACK 영역은 지역변수와 함수 호출 시 매개변수와 돌아갈 주소가 저장됨
            - HEAP 영역은 프로그래머가 런타임시 할당할 수 있는 메모리 공간
                - C 언어의 malloc() : 힙 영역에 메모리 공간 할당
                - C 언어의 free() : 할당된 메모리 공간 해제

### 컴파일 과정

![1a](https://user-images.githubusercontent.com/41246605/210228763-86c08209-2b2e-454f-a24e-17d6bb67b28c.png)

- 컴파일 과정
    - test.c 파일 → 전처리기 → 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러옴 → 전처리기를 거치면 파일의 확장자는 test.i 가 됨 → 컴파일러 (고수준인 C언어를 저수준인 어셈블리어로 변환 (어셈블리어는 명령어가 기계어랑 1:1 매칭이 되기 때문에 기계어랑 가장 가까운 언어) → test.s 로 확장자 변환 → 어셈블러가 어셈블리어를 기계어로 변환함 (이 파일은 0과 1로 이루어진 기계어로 구성되고, 확장자는 test.o 로 변환) → 링커가 링킹을 함 (여러 라이브러리나 다른 소스코드를 연결함) → 파일의 확장자는 .exe 로 변환됨

- CPU 는 0과 1로 이루어진 기계어로 작동함
    - CPU 내 제어장치가 숫자 5와 7을 메모리에 저장함
    - 메모리에 저장된 값을 edx, eax 레지스터로 가져옴
    - 제어장치가 레지스터에 저장된 5와 7을 더하라는 명령을 내림
    - 산술 논리 연산장치가 두 숫자를 더하고, 그 결과를 eax 레지스터에 저장함
    - 다시 제어장치가 eax 레지스터에 저장된 12를 가져와서 메모리에 저장시킴

### 멀티 프로그래밍과 멀티 프로세싱

- 유니프로그래밍과 멀티프로그래밍, 멀티프로세싱
    - 유니프로그래밍은 메모리에 오직 하나의 프로세스가 올라온 것을 말함
    - 멀티프로그래밍은 메모리에 여러 개의 프로세스가 올라온 것을 말함
    - 멀티프로세싱은 CPU 의 관점으로 정의한 것
        - CPU 가 여러 개의 프로세스를 처리하는 것을 말함
- 오늘날 OS 는 멀티프로그래밍과 멀티프로세싱 2가지 방법이 공존함
    - 메모리에는 여러 개의 프로세스가 올라와 있음
    - CPU  는 시분할 처리로 각각의 프로세스를 짧은 시간 동안 교대로 실행하는 멀티프로세싱을 함
- 스와핑 (Swapping)
    - 메모리에 프로세스를 올려서 CPU 로 처리하고, 이 프로세스를 다른 저장장치에 저장함
    - 다른 저장장치에 있던 프로세스를 메모리에 올려서 CPU 로 처리하는 멀티프로세싱 기법을 사용

### PCB

- 프로그램이 메모리에 올라가서 실행중인 상태를 프로세스라고 한다.
- 운영체제는 여러개의 프로세스를 관리하고 공평하게 실행시켜야 합니다.
- 프로세스가 만들어지면 운영체제는 프로세스의 정보를 가지고 있는 PCB 를 만들고 저장합니다.
    - Process Control Block
- PCB 는 연결리스트라는 자료구조의 형태로 저장됩니다.
- 연결리스트는 각각의 데이터가 다음 데이터를 연결하는 구조로 되어있는 자료구조이다.
- 운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB 를 제거한다.

### PCB 의 구조

![2a](https://user-images.githubusercontent.com/41246605/210228773-0e5dceeb-a838-4776-af97-70c35859d592.png)

- 포인터는 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터가 있다.
- 프로세스의 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 가지고 있다.
- 프로세스 상태는 현재 프로세스의 다섯가지 상태 (생성, 준비, 실행, 대기, 완료) 를 나타냅니다.
- 프로세스 ID 는 프로세스를 식별하기 위한 숫자가 저장됨
- 프로그램 카운터는 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터를 저장함
    - OS는 시분할처리로 여러 프로세스를 짧은 시간동안 번갈아 실행함
    - 어떤 프로세스가 실행되다가, 다른 프로세스에게 CPU 를 뺏기고, 다시 돌아왔을 때 원래 실행하려고 했던 명령어를 실행하기 위해 프로그램 카운터가 꼭 있어야 함
- 레지스터 정보는 프로세스가 실행될 때 사용됐던 레지스터 값들이 저장됨
    - CPU 를 뺏기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도
- 메모리 관련정보는 프로세스가 메모리에 있는 위치정보, 메모리 침범을 막기 위한 경계 레지스터 값 등이 저장됨
- CPU 스케줄링 정보에는 CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유 시간 등이 저장됩니다.

### 프로세스 상태

![3a](https://user-images.githubusercontent.com/41246605/210228775-8c6e9456-1500-47f6-80fb-72a3ddd06611.png)


- 시분할 시스템을 사용하는 운영체제는 여러 개의 프로세스를 돌아가면서 실행한다.
- CPU 는 한 순간에 하나의 프로세스밖에 처리하지 못한다는 의미
- 프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있음
    - 생성 상태
        - PCB 를 생성하고 메모리에 프로그램 적재를 요청한 상태
        - 메모리에 프로그램 적재를 승인 받으면 준비상태로 넘어감
    - 준비 상태
        - CPU 를 사용하기 위해 기다리고 있는 상태
    - 실행 상태
        - 준비상태에 있는 프로세스는 CPU 스케줄러에 의해 CPU가 할당받아 실행되는 상태
        - 실행 상태에 있는 프로세스는 CPU 의 개수 만큼 개수를 가짐
        - 실행 상태에 있는 프로세스도 CPU 를 사용할 수 있는 부여된 시간만큼만 사용할 수 있음
        - CPU 스케줄러는 부여된 시간을 초과하면 할당된 CPU 를 강제로 빼앗습니다.
        - 그럼 프로세스는 다시 준비상태로 돌아감
    - 대기 상태
        - 대기 상태는 프로세스가 입출력 요청을 하면 입출력이 완료될 때까지 기다리는 상태
        - 입출력에 대한 대기는 CPU 의 처리 상태에 비해 김
        - 요청이 오기 전까지 프로세스를 대기상태로 두고, 다른 프로세스에게 CPU 를 할당함
        - 입출력 작업이 완료되면 대기상태의 프로세스를 준비상태로 전환함
    - 완료 상태
        - 프로세스가 종료된 상태
        - 프로세스가 사용했던 데이터를 메모리에서 제거하고, 생성된 PCB도 제거함

### 컨텍스트 스위칭

![4a](https://user-images.githubusercontent.com/41246605/210228778-70069cd9-64c8-4601-a917-3178b476ba53.png)

- 컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업
- 컨텍스트 스위칭이 일어날 때 PCB 의 내용이 변경됨
- 실행중인 프로세스의 작업내용을 PCB 에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU 가 다시 세팅됨
- 컨텍스트 스위칭이 일어날 때 PCB 에 변경하는 값들로는 프로세스 상태, 다음 실행할 명령어의 주소를 담고 있는 프로그램 카운터, 레지스터 정보 들이 있다.
- 컨텍스트 스위칭 과정
    - 프로세스 A가 실행을 하는데 CPU 점유시간을 초과하였음
    - 운영체제는 프로세스 A가 CPU 를 너무 오래 사용했다고 판단, 인터럽트를 발생시킵니다.
    - 프로세스 A는 현재 CPU의 레지스터 값 등을 PCB A에 저장합니다.
    - PCB B를 참조해서 이전 프로세스 B의 상태로 CPU의 레지스터값을 설정
    - 다음 실행할 명령어의 주소를 가지고 있는 프로그램 카운터를 통해 프로세스 B의 명령어를 사용함
    - 프로세스 B의 CPU 점유시간을 초과하면, 다시 인터럽트를 발생, 프로세스 A를 실행시킴

### 프로세스 생성과 종료

- 프로세스 생성 과정
    - 사용자가 .exe 와 같은 실행파일을 실행
    - 운영체제는 해당 프로그램의 코드 영역과 데이터 영역을 메모리에 로드하고, 빈 스택과 빈 힙을 만들어 공간을 확보함
    - 프로세스를 관리하기 위한 PCB 를 만들어서 값을 초기화 해줌
- 컴퓨터가 부팅될 때 위의 과정을 거쳐 0번 프로세스를 1번 실행시킴
- 다른 프로세스를 생성할 때는 위의 생성과정을 거치지 않고 fork() 함수를 통해 프로세스를 복사합니다.
- 이때 0번 프로세스는 부모 프로세스, 0번 프로세스를 통해 생성한 프로세스를 자식 프로세스라고 한다.
- 자식 프로세스는 부모 프로세스의 코드 영역, 데이터 영역, 스택 영역과 PCB의 내용을 전부 복사한다.
- fork() 함수 이후 exec() 함수를 실행시키면 부모를 복사한 자식 프로세스의 코드와 데이터 영역을 원하는 값으로 덮어쓰게 됨
- 이때부터 자식 프로세스는 부모 프로세스와 다르게 실행됨
- 자식 프로세스가 모두 종료된 이후 부모 프로세스에게 종료 시그널을 보낸다.
- 부모 프로세스는 모든 자식 프로세스가 종료되면 이후 자신도 종료함
- 부모 프로세스는 종료되었지만 자식 프로세스가 종료되지 못해 메모리에 계속 살아있는 상태가 되는 경우를 좀비 프로세스라고 부름

### 쓰레드

- 운영체제가 작업을 처리하는 단위는 프로세스이다.
- 프로세스를 생성하면 PCB 가 생성되고, 메모리에 코드, 데이터, 스택, 힙영역을 만들어줘야함
- 프로세스 수가 많아지면 각 영역을 만들어줘야하기 때문에 무거워짐
- 웹 브라우저의 탭들은 서로 통신을 하려면 IPC (Inter Process Communication) 을 사용해야 하는데, IPC 는 통신의 비용이 상대적으로 많이 듬
- 쓰레드는 프로세스 내에 존재하는 것으로 1개 이상이 있을 수 있음
- 한 프로세스 내의 쓰레드들은 그 프로세스의 PCB, 코드, 데이터, 힙 영역을 공유합니다.
- 스택은 공유하지 않고 쓰레드마다 하나씩 가지고 있습니다.
- 쓰레드는 하나의 프로세스에서 여러 개 존재할 수 있다보니, 쓰레드 ID 도 생성되고, 쓰레드를 관리하기 위한 TCB (Thread Control Block) 이 생성됨
- 운영체제 관점에서도 쓰레드를 구분할 수 있게됨
- 운영체제가 관리하는 작업의 단위는 쓰레드 단위로 가능하게 되어, 메모리를 효율적으로 사용할 수 있게 됨

### 프로세스와 쓰레드의 장단점

- 프로세스는 서로 독립적이기 때문에 하나의 프로세스가 문제가 있더라도 다른 프로세스는 영향을 받지 않음
- 쓰레드는 하나의 프로세스 내에서 같이 운영되기 때문에 하나의 쓰레드가 장애가 나면 다른 쓰레드에게 영향을 끼칠 수 있음
- 각각의 프로세스는 고유한 자원을 가지고 있어 코드, 데이터, 힙 영역을 각각 가지고 있어야 하며, 프로세스 간 통신을 위해 IPC 통신을 해야함으로 오버헤드가 크고, 속도가 느림
- 쓰레드는 한 프로세스 내에서 스택영역을 제외한 영역은 모두 공유하기 때문에 오버헤드가 굉장히 작으며, 쓰레드 간의 통신은 데이터를 공유하고 있으니 쉽게 할 수 있음



