# 주키퍼란?

---

- 주키퍼는 안정적인 코디네이션 서비스를 목표로 설계되었다.
- 주키퍼는 파일 시스템 API 와 유사한 단순 API 를 제공한다.
    - 마스터 서버 선출
    - 그룹 멤버십 관리
    - 메타 데이터 관리
- 주키퍼는 자바, C, Go API 로 구현되어 있는 애플리케이션 라이브러리이다.
- 전용 서버로 구성된 앙상블 (여러 대의 서버) 에서 동작하는 컴포넌트라고 할 수 있다.
- 주키퍼는 앙상블로 구성되기 때문에 장애처리와 대규모 처리를 가능하게 한다.
- 주키퍼를 사용하여 애플리케이션을 설계할 때 주의점
    - 컨트롤이나 코디네이션 데이터와 애플리케이션 데이터를 구별하는 것이 좋다.
    - 웹 메일 서비스 이용자는 자신의 메일 박스 내용에는 관심이 있지만, 특정 메일 박스에 대한 요청을 어떤 서버가 처리하는지 관심이 없다.
        - 사용자의 메일 박스 내용은 애플리케이션 데이터
        - 메일 박스에 대한 요청을 특정 메일 서버와 관련 짓는 것을 코디네이션 데이터 (혹은 메타 데이터) 라고 할 수 있다. (주키퍼의 관리 대상)

<br />

### 주키퍼의 역할

- 주키퍼는 분산 시스템의 코디네이션 작업을 가능하게 한다.
- 코디네이션 작업은 프로세스들 간의 협력이나 경합을 조절하는 것
    - 협력 : 프로세스들이 작업을 함께 수행해야 하고 다른 프로세스가 진행될 수 있도록 어떤 일을 해야 하는 것
        - 전형적인 마스터 워커 구조에서 워커는 자신이 일을 할 수 있는 상태임을 마스터에게 알리고, 이에 마스터는 작업을 워커에게 할당한다.
    - 경합 : 두 프로세스가 동시에 진행할 수 없는 상황을 의미한다.
        - 그래서 한 프로세스는 다른 프로세스가 끝날 때까지 기다려야 한다.
            - 워커가 단 하나의 마스터만 갖기 운할 경우 프로세스들은 서로 마스터가 되는 것을 시도
            - 여러 프로세스들의 경합 상황에서는 상호배제 (mutual exclusion) 구현이 필요하다.
        - 실제로 락을 획득하는 것 중 하나로 마스터십을 획득하는 일이 예시가 될 수 있다.

- 동기화 기본 요소를 구현하는 메시지 패싱 알고리즘에는 여러 방법이 있지만, 주키퍼처럼 순차적으로 처리해주는 공유 저장소 같은 컴포넌트를 이용하는 것이 더 쉽다.
- 코디네이션은 리더 선출, 락 같은 동기화 기본요소의 형태만을 가지는 것이 아니다.
- 코디네이션에서 설정, 메타데이터는 프로세스 상호 간에 진행 상황을 전달하는 방법으로 이용된다.
- 마스터 워커 시스템의 예에서 워커는 자신에게 할당된 작업을 알아야 하고, 이 정보는 마스터가 장애인 상황에서도 알 수 있어야 한다.

<br />


### 주키퍼가 유용하게 사용된 예시

- 아파치 HBase
    - HBase 는 대표적으로 하둡을 이용하는 데이터 저장소이다.
    - HBase 에서는 클러스터 마스터 선출과 가용 서버들의 목록을 저장하고, 클러스터의 메타데이터를 관리하는데 주키퍼를 사용한다.
- 아파치 카프카
    - 카프카는 발행 구독 기반의 메시징 시스템이다.
    - 카프카는 장애 감지, 토픽 디스커버리, 토픽에 대한 생성과 소비 상태를 관리하는데 주키퍼를 이용한다.


<br />

### 주키퍼 API 의 장점

---

- 견고한 일관성, 순서, 내구성 보장
- 동기화 기본 요소(synchronization primitive)를 구현
- 분산 시스템에서 부정확한 동작을 발생시키는 다양한 동시성 관련 문제를 해결할 수 있도록 단순화된 해법 제공

<br />

### 주키퍼의 역할이 아닌 것

---

- 주키퍼는 대용량 저장소가 아니다.
    - 주키퍼를 사용하는 애플리케이션은 애플리케이션 데이터와 제어 혹은 코디네이션 데이터를 분리하는 것이 바람직하다.
- 주키퍼는 마스터를 선출하지 않고, 애플리케이션에 대해 응답하는 프로세스들을 체크하지 않는다.
    - 대신 이 기능들을 구현할 수 있는 도구를 제공한다.
    - 개발자는 이를 통해 개발하고자 하는 대상의 취사 선택이 가능해진다.

<br />

### 주키퍼를 이용한 분산 시스템 구성

---

- 분산 시스템 : 다양한 소프트웨어 컴포넌트로 구성되어 여러 대의 물리적 장비에서 독립적으로 동시에 실행하는 시스템
- 분산 시스템은 복제도니 여러 컴포넌트를 병렬로 실행하는 것으로 다중 프로세서 (multiple processor) 를 활용이 가능하다.
- 독립된 코디네이션 컴포넌트를 구성하는 이점
    - 컴포넌트를 독립적으로 설계하고 구현할 수 있다.
    - 시스템 아키텍트가 간단하지 않은 코디네이션의 관점을 쉽게 추론하도록 한다.
        - 대부분 프로세스는 여러 개의 스레드로 실행된다.
        - 주키퍼 서버와 클라이언트 역시 프로세스이다.
        - 보통 하나의 물리 서버는 하나의 애플리케이션 프로세스를 실행한다.
        - 그 프로세스는 여러 개의 스레드를 실행해서 멀티 코어 프로세서를 활용한다.

- 분산 시스템에서는 프로세스들이 서로 통신하기 위한 두가지 방법이 있다.
    - 프로세스가 네트워크를 통해 메시지를 직접 교환
    - 공유 저장소에 메시지를 읽고 쓴다.
- 공유저장소는 필연적으로 프로세스와 저장소 간에 네트워크 통신이 필요하다.

<br />

### 분산시스템에서의 주요 쟁점

- 메시지 지연
    - 메시지는 네트워크 혼잡 상황에서 일시적으로 지연될 수 있다.
- 프로세서 속도
    - 운영체제 스케줄링과 부하는 메시지 처리를 할 때 일시적인 지연을 유발할 수 있다.
    - 어떤 프로세스가 다른 프로세스에게 메세지를 보낼 때, 전체 메시지 전송 시간은 대략 보내는 쪽의 처리 시간, 전송 시간, 받는 쪽의 처리 시간의 합
    - 메세지를 보내거나 받는 프로세스가 스케줄 되는데 시간이 소요된다면 전체 메세지 전송 시간은 늘어나게 된다.
- 클럭 드리프트
    - 클럭 이벤트의 발생으로 인한 시간은 신뢰할 수 없다.
    - 프로세스의 클럭에 의존하는 것은 잘못된 결정이다.

<br /><br />


## Master - Worker 애플리케이션

---

- 마스터는 워커와 태스크의 가용 여부를 확인하는 역할을 한다.
- 마스터 워커 아키텍처는 주키퍼의 대표적 사례
    - 마스터 워커 아키텍처는 마스터 선출, 가용 워커 추적, 애플리케이션 메타데이터 유지와 같은 작업을 수행한다.

<br />

### Master - Worker 의 대표적 장애사례

- 마스터 장애
    - 마스터에 결함이 있어서 가용하지 않게 되면 시스템은 워커로부터 새로운 작업을 할당하거나 작업을 재할당하지 못하게 되어 워커 역시 실패하게 된다.
- 워커 장애
    - 워커에 장애가 발생하면 할당된 태스크는 완료되지 못할 것이다.
- 통신 장애
    - 마스터와 워커가 메시지를 교환할 수 없다면 워커는 자신에게 할당되는 새로운 작업을 알 수 없다.


<br />

### Master 장애

- 마스터 장애를 복구하기 위해서는 백업 마스터가 필요하다.
- 주 마스터에 장애가 발생하면 백업 마스터가 주 마스터 역할을 넘겨 받아야 한다.
- 새로운 주 마스터는 이전 마스터 장애 시점의 상태를 복구할 수 있어야 한다.

<br />

### Worker 장애

- Worker 의 기본 동작 방식
    - 클라이언트가 작업을 마스터로 전송하면 마스터는 가용한 워커에게 작업을 할당한다.
    - 워커는 할당된 작업을 실행하고 그 상태를 마스터에게 알려준다.
    - 워커의 작업이 끝나면 마스터는 실행 결과를 클라이언트에게 알려준다.
- Worker 장애 발생 시
    - Worker 에 장애가 발생하면 해당 워커에 할당된 작업은 완료되지 않는다.
    - 작업은 재할당 되어야 한다.
    - 이에 마스터는 반드시 워커 장애를 감지할 수 있어야 하고, 작업을 가용 워커에게 재할당할 수 있어야 한다.
    - 하나의 워커에 장애가 발생하는 경우에도 작업은 일부만 실행될 수 있다.
    - 필요에 따라 복구 절차에서 상태를 초기화해야할 수 있다.

<br />

### 통신 장애

- 네트워크 분리로 워커와 마스터의 연결이 끊어졌을 때 작업을 재할당하면 두 워커에게 동일한 작업을 할당하게 될 수 있다.
- 작업이 만일 한 번만 실행되어야 하는 경우라면 애플리케이션은 반드시 여러 워커가 동일한 작업을 실행할 수 있는 가능성을 고려해야 한다.


<br />


### 정확히 한 번과 최대 한 번의 의미

---

마스터 선출과 같은 작업이 여러 번 실행되는 것을 방지하려고 락을 사용하는 것은 적합하지 않다.

- 마스터 M1 이 작업 T1 을 워커 W1 에게 할당한다.
- W1 이 T1 을 처리하기 위해 락을 획득하고 실행한 뒤 락을 해제한다.
- 마스터 M1 은 W1에 장애가 발생했다고 의심하고 테스크 T1 을 워커 W2 에게 재할당한다.
- W2 는 T1 을 처리하기 위해 락을 획득하고 실행한 뒤 락을 해제한다.

이 때 T1 의 락은 작업이 두 번 실행되는 것을 막지 못한다.

두 워커는 작업을 번갈아가면서 실행하지 않기 때문이다.

또한, 노드에 장애가 발생하거나 네트워크 분리가 발생한다면 락은 작업 진행을 멈추게 한다.


<br />


### Zookeeper 의 극복방안

---

- 클라이언트가 데이터를 임시 상태라고 정의할 수 있게 한다.
- 주키퍼 앙상블은 클라이언트가 자신이 살아있는지 주기적으로 알려주는 기능
    - 클라이언트가 주키퍼 앙상블에게 일정한 시간 내에 자신의 상태를 알려주는 것에 실패하면 주키퍼 앙상블은 해당 클리언트에 속한 모든 임시 (ephemeral) 상태를 제거한다.

위의 두가지 방법으로 주키퍼는 장애나 통신 실패 시 클라이언트가 애플리케이션을 중단하지 않게 했다. ( 락을 걸지 않고, 상태에 대해 Noti만 하고 끝냈으니까 )


<br />


### Zookeeper 의 작업 요약

---

- 마스터 선출
    - 작업을 진행하려면 워커에게 작업을 할당할 수 있는 마스터가 있어야 한다.
- 장애 감지
    - 마스터는 워커 장애가 발생하거나 연결이 끊어졌을 때 감지할 수 있어야 한다.
- 그룹 멤버십 관리
    - 마스터는 어떤 워커들이 작업을 실행할 수 있는지 알아낼 수 있어야 한다.
- 메타데이터 관리
    - 마스터와 워커는 작업과 실행 상태를 신뢰할 수 있는 방법으로 저장할 수 있어야 한다.


<br />

### 분산 코디네이션이 어려운 이유

---

- 애플리케이션이 실행되고, 서로 다른 프로세스들이 애플리케이션의 설정이 필요한 경우
    - 시간이 지나면서 설정은 변경됨
    - 설정이 변경되면 모든 프로세스를 종료하고 설정 파일들을 재배포한 뒤 재시작
    - 설정을 변경하는 동안 애플리케이션의 다운타임이 길어지게 됨
    - 애플리케이션의 부하가 변경됨에 따라 새로운 장비나 프로세스를 추가하거나 제거할 수 있어야 한다.

- 분산 애플리케이션의 장애로 인한 어려움
    - 단일 애플리케이션의 장애
        - 장비에서 실행 중인 모든 프로세스는 실패한다.
        - 여러 프로세스들이 실행 중인 단일 장비에서 어떤 프로세스가 실패하면 다른 프로세스는 운영체제로부터 실패에 대한 내용을 찾을 수 있다.
        - 운영체제는 프로세스 간에 견고한 통신을 보장한다.
    - 분산 애플리케이션의 장애
        - 분산 애플리케이션은 부분적인 장애가 발생할 수 있다.
        - 특정 장비나 프로세스에 장애가 생기는 경우에도 다른 장비는 계속해서 실행되어야 한다.
        - 장애가 발생한 프로세스를 다른 장비가 이어받을 수 있어야 한다.

- 이상적인 시스템은 통신이 비동기적이라고 가정하고 설계한다.


