## 주키퍼의 기본

---

- 코디네이션이 필요한 서비스를 만드는 방법
    - 기본 요소 목록을 작성
    - 각 기본 요소의 인스턴스를 생성하는 호출을 제공
    - 생성된 인스턴스를 직접 조작

- 분산 락은 핵심 기본 요소이고, 생성, 획득, 해제에 대한 호출을 제공한다.

- 주의사항
    - 미리 빠짐없이 기본 요소 목록을 찾아내지 않으면 새로운 기본 요소를 도입하기 위해 API를 계속해서 추가해야 한다.
    - 기본 요소를 특정 서비스에만 적합하게 구현한 서비스를 사용하는 애플리케이션은 유연성을 제공하지 못한다.

<br />

### 주키퍼의 접근 방법

- 기본 요소를 직접 제공하지 않는 대신 애플리케이션이 직접 기본 요소를 구현할 수 있는 호출들로 구성된 파일 시스템과 같은 API 를 제공한다.
- 주키퍼는 기본 요소를 표현하기 위해 레시피를 사용한다.
    - 레시피 : 파일 시스템의 트리(tree) 처럼 계층적으로 구성된 znode 라고 부르는 작은 데이터 노드를 조작하는 주키퍼 작업(operation) 이다.
- 가끔 znode 의 데이터가 없는 것은 현재 선출된 마스터가 없다는 의미이다.

<br />

### Node 의 종류

- /workes
    - /works znode 는 부모 znode 로 시스템상에서 가용한 워커의 정보를 담고 있는 znode 이다.
    - 일을 할 수 있는 모듈의 정보를 갖고 있는 znode
- /tasks
    - /tasks znode 는 워커가 실행할 작업이 생성되어 실행 전까지 저장되는 부모 znode 이다.
    - 마스터 워커 애플리케이션의 클라이언트는 신규 작업을 의미하는 신규 znode 를 /tasks 노드의 자식 노드로 추가하고 작업의 상태를 나타내는 znode 를 가리킨다.
    - 작업 대상에 대한 정보를 갖고 있는 znode
- /assign
    - /assign znode 는 워커에게 할당된 모든 작업을 나타내는 부모 znode 이다.
    - 마스터가 워커를 할당할 때 /assign 에 자식 znode 를 할당한다.
    - 어떤 워커가 어떤 작업을 하는지에 대한 정보를 갖고 있는 znode

<br />

## 주키퍼 API

---

- znode 는 데이터를 담거나 담고 있지 않을 수 있다.
- znode 에 데이터가 담겨 있는 경우 데이터는 바이트 배열 (byte array) 로 저장된다.
- 바이트 배열의 포맷은 각 애플리케이션에서 정의한다.
- 경우에 따라 UTF-8, ASCII 와 같은 문자열 인코딩이 필요하다.
- 주키퍼 클라이언트는 주키퍼 서비스에 연결하고 API 호출을 통해 세션을 맺는다.

<br />

### API 의 종류

- create /path data
    - data 를 담고 있는 /path 라는 이름의 znode 를 생성한다.
- delete /path
    - /path znode 를 삭제한다.
- exists /path
    - /path znode 가 존재하는지 확인한다.
- setData /path data
    - /path znode 의 데이터를 data로 저장한다.
- getData /path
    - /path 의 데이터를 반환한다.
- getChildren /path
    - /path 의 자식 목록을 반환한다.

<br />

### Znode 의 다양한 모드

- znode 는 영구적 (persistent) 이거나 임시적 (ephemeral) 으로 존재할 수 있다.


- 영구 znode
    - /path 는 delete 를 호출함으로써 삭제할 수 있다.
    - 애플리케이션 데이터를 저장하는데 유용하다.
    - 애플리케이션이 더 이상 사용할 수 없게 되어도 보존한다.
    - 마스터가 작업을 할당하고 장애가 발생해도 워커에게 할당된 작업들을 유지해야 한다.


- 임시 znode
    - znode 를 생성한 클라이언트가 주키퍼와 클라이언트의 연결이 끊어지거나 클라이언트 장애가 발생하게 되면 삭제된다.
    - 애플리케이션의 특정 관점에 대한 정보를 저장한다.
    - 임시 znode 는 znode를 생성한 클라이언트의 세션이 존재하는 동안 유효하다.
    - 마스터 워커 예제에서 마스터 znode 는 임시 znode 이다.
        - 마스터 znode 가 존재한다는 것은 마스터가 실행 중임을 의미한다.
        - 마스터가 문제가 발생했을 때 마스터 znode 가 존재한다면 시스템은 마스터 장애를 감지하지 못할 것이다.
        - 마스터 znode 는 반드시 마스터와 함께 제거되어야 한다.
    - 워커 역시 임시 znode 를 사용한다.
        - 워커가 이용 불가능해진다면 워커와 주키퍼 간의 세션은 만료되고 /workes 내의 워커를 나타내는 znode 는 자동으로 사라진다.
    - 임시 znode 는 다음과 같은 두가지 경우에 삭제된다.
        - 임시 znode 를 생성한 클라이언트의 세션이 만료되거나 명시적으로 세션이 끝나는 경우
        - 클라이언트가 삭제한 경우
    - znode를 생성한 클라이언트의 세션이 만료되면 임시 znode 가 삭제되기 때문에 현재 임시 znode 는 자식 znode 를 가질 수 없다.


- 순차 znode (sequential)
  - znode 는 순차적으로 생성될 수 있다.
  - 순차 znode 는 유일하면서 점차 증가하는 정수로 할당된다.
  - 이 순차 번호는 znode 를 생성할 때 사용되는 경로에 덧붙여진다.
    - /tasks/task-1


- znode 는 영구, 임시, 영구순차, 임시순차 노드로 4가지 선택사항이 있다.


<br /><br />

## 와치와 알림

---

- 주키퍼는 클라이언트의 폴링 (매번 이벤트의 발생여부를 체크해야하는) 을 대체하기 위해 알림에 기반한 메커니즘을 선택했다.
- 클라이언트는 주키퍼에게 znode 의 변경 사항에 대한 알림을 받겠다고 등록한다.
- 와치(watch) 를 설정하는 것으로 znode 에 대한 알림 받기가 등록된다.
- 와치는 알림이 한 번만 발생하는 일회성 (one-shot) 작업이다.
- 계속해서 알림을 받으려면 클라이언트는 받고자 하는 각 알림마다 반드시 새로운 와치를 설정해야 한다.
- 클라이언트는 /tasks znode 값의 변경을 나타내는 알림을 받으면 주키퍼에서 새로운 값을 읽어온다.

### 주의사항

- 클라이언트가 알림을 받고 새로운 와치를 등록하기 이전에 신규 변경 사항이 생기는 현상이 발생할 수 있음
  - 클라이언트 c1 이 새로운 와치를 설정하기 이전에 또 다른 세 번째 클라이언트 c3 가 신규 작업을 /tasks 에 등록한다.

- 주키퍼의 알림이 확실하게 보장하는 것은 동일한 znode 에 대해 다른 변경 사항이 생기기 이전에 클라이언트에게 전달된다는 것
- 알림은 클라이언트가 감시하고 있는 znode 의 변경 사항의 순서를 보존한다는 것이다.
- 주키퍼에게 관리되는 전역 순서에 따라 클라이언트는 주키퍼의 상태 변경 사항을 순서대로 감시하는 것이 보장된다.
  - 첫 번째 변경사항에 대한 이벤트 발생 후 , 와치를 재 등록해야 다음 변경사항에 대한 알림을 받을 수 있기 때문이다.

### 주키퍼 알림의 이벤트 유형

- 주키퍼는 와치가 설정하는 알림에 따라 다른 유형의 알림을 보낸다.
  - 클라이언트는 znode 의 데이터가 변경되었을 때
  - 자식 znode 가 변경되었을 때
  - znode가 생성되거나 삭제 되었을 때
- 주키퍼의 상태를 읽는 API 호출로 와치를 설정할 수 있다.

<br /><br />


## 주키퍼 아키텍처

---

- 애플리케이션은 클라이언트 라이브러리를 이용해서 주키퍼를 사용한다.
- 클라이언트 라이브러리는 주키퍼 서버와 통신하는 역할을 한다.

<br />

### 주키퍼 서버

- 주키퍼 서버는 단독 (standalone) 또는 쿼럼 (quorum) 의 두가지 모드로 실행된다.
  - 단독 모드
    - 단독모드는 말 그대로 하나의 서버에서 실행되는 것
    - 단독 모드에서는 주키퍼의 상태는 복제되지 않는다.
  - 쿼럼 모드
    - 주키퍼 앙상블이라고 부르는 주키퍼 서버들의 그룹
    - 쿼럼 모드에서는 상태가 복제됨
    - 서버들이 클라이언트의 요청을 함께 처리함

<br />

### 주키퍼 쿼럼

- 주키퍼는 쿼럼 모드일 때 데이터 트리를 아상블에 속한 모든 서버로 복제한다.
- 주키퍼에서 쿼럼은 주키퍼가 작동하기 위해 실행 중이고 가용한 최소 서버 수다.
- 이 수는 클라이언트에게 데이터를 안정적으로 저장했다고 알려줄 수 있는 최소 서버 수이다.
- 총 5대의 주키퍼 서버가 있는 경우 쿼럼은 3대이다.
  - 3대의 서버에 데이터가 저장되면 클라이언트는 블록되지 않고 계속 진행할 수 있게 된다.
  - 다른 2대의 주키퍼 서버는 상태의 변경사항을 따라가서 데이터를 저장할 것이다.

<br />

### 쿼럼의 크기 선정

- 충분한 크기의 쿼럼을 선택하는 것은 중요하다.
  - 쿼럼은 지연이나 시스템에 관계없이 주키퍼 서비스에 대한 어떠한 변경 요청이라도 받아들여 다른 요청이 대체하기 전까지 변경사항을 지속하는 것으 보장해야 한다.
- 쿼럼 크기는 앙상블을 구성하는 5대 중 과반수가 넘는 최소한 3대가 되어야 한다. (홀수)
- 앙상블이 동작하려면 최소한 3대의 가용 서버가 필요하다.
  - 상태 변경 요청이 성공적으로 완료되는 것을 보장하려면 이 앙상블은 최소한 3대의 서버로부터 복제했다는 승인을 받아야 한다.
  - 따라서 앙상블이 유지되려면 최소한 한 대의 서버가 성공적으로 완료된 모든 변경사항을 갖고 있어야 한다.
  - 과반수 정책을 사용하면 앙상블 서버의 반보다 작은 f 대의 서버 장애를 허용하는 것이 가능하다.
- 전체 짝수 대의 앙상블 구성은 비효율적이다.
  - 4 대를 쿼럼의 크기로 선정하면, 과반수는 3이기 때문에 오직 1대의 서버만 장애를 허용하게 된다.
  - 또한 4대지만 과반수인 3대의 서버로부터 복제했다는 승인을 받아야 한다.

<br />

### 세션

- 주키퍼 앙상블에 어떤 요청을 하기 이전에 클라이언트는 반드시 주키퍼 서비스와 세션을 수립해야 한다.
- 어떠한 이유로든 세션이 종료되면 세션에서 생성됐던 임시 노드는 제거된다.

<br />

### 세션 획득 과정

- 클라이언트가 특정 언어 바인딩을 사용해 주키퍼 핸들을 생성하면 주키퍼 서비스와 클라이언트의 세션이 수립된다.
- 초기에 클라이언트는 아상블의 서버 중 하나에 연결된다.
- 클라이언트는 TCP 연결을 사용해서 서버와 통신한다.
- 특정 시간동안 연결되어있는 서버로부터 응답을 받지 못한다면 세션은 다른 서버로 옮겨질 수 있다.

<br />

### 세션 요청 처리 순서

- 세션은 FIFO 순서로 순서를 보장한다.
- 일반적으로 클라이언트는 하나의 세션을 사용하고 요청은 FIFO 순서대로 실행된다.
- 클라이언트가 동시에 여러 개의 세션을 가진다면 세션 간에 FIFO 순서는 지켜지지 않는다.

