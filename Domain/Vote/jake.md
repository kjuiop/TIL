# 투표 

---

# 목차

---

- 투표기능
    - 예약 투표
    - 투표 제목, 내용, 이미지 지정
    - 기간 설정
    - 카테고리 설정 (홈, 커뮤니티, 종목, 테마 등)
    - 투표 항목 명칭 및 이미지 지정 가능
    - 단일 투표
    - 복수 투표
    - 선착순 투표

투표시스템 요구사항은 예약, 기간 설정, 단일 투표, 복수 투표, 선착순 투표 등의 기능이 포함됐습니다.

해당 요구사항을 받은 저는 ‘어떤 성격을 지닌 투표를 객체로 활용하면 좋을까?’ 하는 고민 시작

### 공통으로 적용할 수 있는 특성

---

- 예약 투표
- 단일 투표 / 복수 투표
- 기간 투표 / 무기한 투표
- 카테고리 설정
- 투표 / 투표 항목 제목, 내용, 이미지 지정

### 공통으로 적용하지 못하는 특성

---

- 일반 투표
- 선착순 투표

# 투표 시스템 아키텍처 요구사항

---

## 요구사항 1. 사용자가 투표를 하고, 서버는 투표 결과를 알려준다.

- 투표하겠습니다.
- 투표 완료했습니다. or 실패했습니다.

## 요구사항 2. 비즈니스가 언제든지 바뀔 수 있기 때문에 항상 다른 투표가 추가적으로 생기거나 삭제될 경우를 대비해야 한다.

- 일반투표
- 선착순투표
- 주주 투표
- 관심 종목 투표 등등..

## 요구사항 3. 여러명이 동시에 투표할 경우, Race Condition 이 발생하기 때문에 이를 대비해야 한다.

![Screen Shot 2022-11-06 at 12 05 23 PM](https://user-images.githubusercontent.com/41246605/200152524-cbd94e0b-1fd4-4768-b595-57811d9695b3.png)




- 사용자가 여러명이 동시에 투표하는 것이 왜 문제일까?
    - 100명이 동시에 투표를 하게된다면, DB에 100이라는 숫자가 더해지지 않고 100에 못 미치는 숫자의 값이 증가됩니다.
    - 한 번에 여러 쓰레드가 현재 카운트를 읽고, 현재 카운트에 1만 증가된 값으로 여러 쓰레드가 업데이트하기 때문이다. 위 그림과 같이 Thread4까지 1로 업데이트 하는 현상을 확인 할 수 있습니다.

<br />
<br />

# 투표 시스템 아키텍처

---


![Screen Shot 2022-11-06 at 12 08 23 PM](https://user-images.githubusercontent.com/41246605/200152531-a73460bc-da8a-44a8-ac71-08d66604e71a.png)

<br />

### 요구사항 1 에서 사용자는 투표를 하고, 서버는 투표 결과를 알려준다는 문구를 사용했습니다.

<br />

![Screen Shot 2022-11-06 at 12 09 10 PM](https://user-images.githubusercontent.com/41246605/200152532-8059d2b0-b6c5-4d5e-bea2-7d5ce6e5c9b0.png)



저희는 현재 Layerd Architecture 를 사용하고 있으며 Presentation Layer 와 Service Layer 사이에 각 Service 간 의존하는 것을 막기 위해 Facade Layer 를 추가적으로 사용하고 있습니다.

유저가 “투표합니다”라는 요청을 보낼 경우, Facade Layer에서도 하위 모듈(투표 구현체-일반투표, 선착순투표, 주주 투표, 관심 종목 투표 등)을 직접적으로 의존하는 것이 아닌 상위 모듈인 투표 타입 인터페이스를 의존해야 합니다.

이는 컴파일 레벨에서의 의존성을 고정시키지 않고, 런타임 레벨에서의 의존성을 변경시킬 수 있으며 DIP를 지킬 수 있는 설계가 됩니다.

### 요구사항 2 처럼 비즈니스는 항상 변동되기 때문에 투표가 늘어나거나 삭제되도  클라이언트 코드에 영향을 주지 않아야 합니다.

<br />
그렇기 때문에 투표타입이라는 인터페이스를 두고 일반투표(DefaultVote)라는 구현체를 베이스로 하나 두고, 추가적으로 확장되는 투표들을 Decorator 패턴을 사용해 OCP 를 위배하지 ㅇ낳고 다양한 투표를 추가/삭제할 수 있습니다.

Decorator 패턴을 선택한 이유는 선착순 투표, 주주투표 등 어떤 투표던 간에 기본적인 투표시스템이 갖춘 기능을 사용하기 위함입니다.

# 선착순 투표 아키텍처

---

![Screen Shot 2022-11-06 at 12 18 01 PM](https://user-images.githubusercontent.com/41246605/200152534-1b01a527-25d4-40f8-b93c-943baf3028d2.png)


### 요구사항 3 : 선착순 투표는 동시성을 제어해야 한다.

동시성을 제어하는 방법은 다양한 방법 (Redis Distributed Lock, DB Optimistic Lock, Pessimistic Lock, Named Lock 등 ) 이 존재합니다. 이번 포스팅은 동시성 제어에 초점이 맞춰진 포스팅이 아니기 때문에 각각의 특징을 설명하진 않겠습니다. 저는 이 중 저희 프로젝트 환경에서 가장 알맞은 Named Lock을 선택했습니다.

현재 프로젝트에서 Named Lock 을 처음 도입하는 것이기 때문에 팀원들도 다음에 편하게 사용할 수 있도록 NamedLockTemplate 을 구현했습니다. NamedLockStategy 구현체를 받아서 해당 구현체의 비즈니스 로직이 실행하기 전에 NamedLock 을 잡고 비즈니스 로직이 끝난 후에 NamedLock 을 해제하는 역할을 합니다.

추후에 투표라는 도메인이 아닌 다른 도메인에서도 NamedLock 은 Strategy 패턴을 사용해서 다양한 도메인에 적용할 수 있도록 합니다.


# Reference

---

- [https://zuminternet.github.io/vote-architecture/](https://zuminternet.github.io/vote-architecture/)


