### JPA 에서 Entity 를 설계할 때 주의점을 말해주세요.

1. 객체 지향적인 설계를 고려해야 합니다.
   JPA의 Entity는 객체 지향적인 설계를 고려하여 작성해야 합니다. 데이터베이스 테이블과 매핑되는 객체는 상태와 행위를 함께 가지고 있어야 합니다. 이를 위해 객체지향 설계 원칙 중 캡슐화, 상속, 다형성 등을 적용할 수 있어야 합니다.
2. 식별자를 잘 선택해야 합니다.
   JPA의 Entity에서 식별자(identifier)는 객체를 구분할 수 있는 유일한 값입니다. 따라서, 식별자를 잘 선택해야 합니다. 대표적으로 Long, String, UUID 등이 있으며, 특히 Long 타입을 사용할 때는 auto increment를 사용하면 성능에 이점이 있습니다.
3. 영속성 컨텍스트(Persistence Context)의 개념을 이해해야 합니다.
   JPA에서 영속성 컨텍스트는 Entity의 상태를 관리하는 매커니즘입니다. Entity를 조회하거나 저장할 때, 영속성 컨텍스트를 통해 데이터베이스와 상호작용합니다. 이를 이해하면, Entity를 사용할 때 적절한 상태 관리가 가능해집니다.
4. ***Entity 간의 관계 설정이 중요합니다.***
   JPA에서는 Entity 간의 관계 설정을 통해 객체 간의 연관성을 표현할 수 있습니다. 이 때, 다양한 관계 설정을 이해하고 적절하게 사용해야 합니다. 예를 들어, 일대일, 일대다, 다대일, 다대다 등의 관계를 설정할 수 있으며, 각각의 관계마다 다양한 연관관계 주인과 매핑 방법이 존재합니다.
5. 적절한 fetch 전략을 선택해야 합니다.
   JPA에서는 Entity를 조회할 때 데이터를 어떻게 가져올지(fetch)를 결정할 수 있습니다. 이 때, 적절한 fetch 전략을 선택해야 합니다. 대표적으로 Eager Fetch와 Lazy Fetch가 있으며, Lazy Fetch를 사용하면 성능상 이점이 있을 수 있습니다.
6. 적절한 성능 최적화가 필요합니다.
   JPA에서는 일반적으로 느린 I/O 작업이 많기 때문에, 적절한 성능 최적화가 필요합니다. 예를 들어, ***Entity Graph나 QueryDSL을 사용하여 적절한 쿼리를 작성***하거나, 캐시를 적극적으로 사용하여 성능을 향상시킬 수 있습니다. 또한, ***지연 로딩(Lazy Loading)을 사용하여 필요한 시점에만 데이터를 로딩하도록 처리함으로써 성능을 최적화***할 수 있습니다.
7. 데이터베이스 스키마 관리가 필요합니다.
   JPA를 사용하면 Entity와 데이터베이스 스키마 간의 매핑을 자동으로 처리할 수 있습니다. 하지만, 이는 초기 개발 단계에서만 유효하며, 프로젝트가 진행되면서 데이터베이스 스키마가 변경될 수 있습니다. 이 때, 데이터베이스 스키마 관리가 필요하며, 이를 위해 Flyway나 Liquibase와 같은 도구를 사용하여 스키마 마이그레이션을 자동화할 수 있습니다.
8. 다양한 JPA 구현체가 존재합니다.
   JPA는 자바 ORM 기술의 표준이지만, JPA를 구현한 다양한 라이브러리가 존재합니다. 대표적으로 Hibernate, EclipseLink, OpenJPA 등이 있으며, 이들 라이브러리 간에는 차이점이 존재합니다. 따라서, 적절한 JPA 구현체를 선택해야 하며, 선택한 JPA 구현체에 맞는 코드를 작성해야 합니다.

<aside>
💡 JPA 는 Java - DB 중간에 Layer 를 두어 매핑 시켜주는 것
그러면 무조건적으로 성능이 느릴까?

</aside>

### JPA 의 특성 중 영속성 컨텍스트의 개념과 동작방식에 대해 설명

- JPA(Java Persistence API)에서 영속성 컨텍스트(Persistence Context)는 JPA에서 가장 중요한 개념 중 하나입니다. 영속성 컨텍스트는 JPA가 제공하는 기능 중 가장 핵심적인 기능 중 하나이며, 엔티티(Entity)의 상태를 관리하고 데이터베이스와의 통신을 처리합니다.
- 영속성 컨텍스트는 엔티티 매니저(Entity Manager)를 통해 생성됩니다. 엔티티 매니저는 JPA에서 영속성 컨텍스트를 생성하고, 관리하며, 엔티티의 CRUD(Create, Read, Update, Delete) 작업을 수행합니다.
- 영속성 컨텍스트는 엔티티 매니저와 동일한 생명주기를 가지며, 엔티티 매니저가 종료될 때 영속성 컨텍스트도 함께 종료됩니다. 따라서, 영속성 컨텍스트가 관리하는 엔티티는 엔티티 매니저가 종료되기 전까지 유지됩니다.

- 영속성 컨텍스트가 관리하는 ***엔티티는 1차 캐시(First-Level Cache)에 저장됩니다. 1차 캐시는 영속성 컨텍스트 내부에 존재하는 캐시***로, 엔티티의 식별자를 키(Key)로 사용하여 엔티티 객체를 저장합니다. 이러한 방식으로 1차 캐시를 사용함으로써, 같은 엔티티를 조회할 때마다 데이터베이스에 접근하지 않고, 영속성 컨텍스트 내부에서 캐시된 엔티티를 반환하여 성능을 향상시킵니다.
- 또한, 영속성 컨텍스트는 엔티티의 변경 사항을 추적하고, 데이터베이스에 자동으로 반영합니다. 즉, 엔티티의 상태를 변경할 때마다, 엔티티 매니저를 통해 영속성 컨텍스트에 변경된 내용을 전달하면, ***영속성 컨텍스트는 변경된 내용을 즉시 반영하지 않고, 내부적으로 Dirty Checking을 수행하여, 데이터베이스와의 동기화 시점을 결정합니다. 이러한 방식으로 영속성 컨텍스트는 엔티티의 상태를 추적하고, 변경 사항을 관리하여 데이터베이스와의 통신을 최적화하며, 성능을 향상시킵니다.***
- 최종적으로, 영속성 컨텍스트는 JPA의 핵심 기능 중 하나이며, 엔티티의 상태를 추적하고, 데이터베이스와의 통신을 최적화하여 성능을 향상시킵니다. 따라서, JPA를 사용하면 영속성 컨텍스트를 적극적으로 활용하여 ***데이터베이스와의 통신을 최소화하고, 성능을 최적화***할 수 있습니다.